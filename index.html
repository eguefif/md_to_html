
    <html>
<head>
<link rel="stylesheet" href="/home/eguefif/lab/career_manager/html/website/dev/css/styles.css">
</head>
    <body>

            div class="content" style="margin: auto">
<div class="article">
    <div class="article-header">
        <h1>Websocket example</h1>
        <div class="article-date">
            Saturday 5,
        </div>
    </div>
    <div class="article-content">
<h1 class="md">Writing a WebSocket echo server in Rust: the handshake</h1><p class="md">Websocket are a convenient way to maintain a connexion between a server and client using all the existing http infrastructure. In this article, we'll cover the basic of a working websocket echo server. We will cover the handshake and frame concept.<br/>Here is a link to the <a href="https://datatracker.ietf.org/doc/html/rfc6455" class="md">rfc 6455</a><br/>Here is the repo for the full code and branch step.</p><h2 class="md">The server Handshake</h2><h3 class="md">A basic TCp server</h3><p class="md">I like to start with how I'm gonna use the code I will write. In our case, we want to run a server. Let's write our main:</p><p class="md"><span class="md line-code"></span><span class="md line-code">rust
fn main() -> std::io::Result<()> {
    run_server("127.0.0.1", 8000)?;
    Ok(())
}
   </span><span class="md line-code"></span></p><p class="md">Starting with the function helps us define our needs. By doing so, we also find our entry point. Let's add to this file the following function.</p><p class="md"><span class="md line-code"></span><span class="md line-code">rust
use std::net::TcpListener;
use std::thread;</span></p><p class="md">pub fn run<em class="md">server(ip: &str, port: u32) -> std::io::Result<()> {
    let listener = TcpListener::bind(format!("{}:{}", ip, port))?;
    for stream in listener.incoming() {
        match stream {
            Ok(socket) => {
                thread::spawn(move || println!("Handling new connection: {:?}", socket));
            }
            Err(e) => eprintln!("Error: {e}"),
        }
    </em></p><p class="md">    Ok(())<br/>}</p><p class="md"><span class="md line-code"></span><span class="md line-code"></span></p><p class="md">This function creates a <a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html" class="md">TcpListener</a> and anytime a new connection is opened with a client, it spawn a new thread to handled it.</p><p class="md">Let's test it with telnet:</p><p class="md"><span class="md line-code"></span><span class="md line-code">bash
$ telnet 127.0.0.1 8000
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
Connection closed by foreign host.</span></p><p class="md"><span class="md line-code"></span><span class="md line-code">
It worked meaning that our basic tcp server handle new connection.</span></p><h3 class="md">Reading a HTTP request</h3><p class="md">From now on, we will use Postman to craft WebSocket packet. Here is the download <a href="https://www.postman.com/downloads/" class="md">link</a>. The software is free.</p><p class="md">Let's read our socket until the end of the Http header. We won't go through the <a href="https://datatracker.ietf.org/doc/html/rfc9112" class="md">rfc 9112</a>. We just need to know that a Http header is terminated by the \r\n\r\n. Let's refactor our code a little bit. We will first create a handle<em class="md">client function and a WebSocket structure</em></p><p class="md">Here is our new <span class="md line-code">run_server</span> function and the new <span class="md line-code">handle_client</span> function:</p><p class="md"><span class="md line-code"></span><span class="md line-code">rust
use std::net::TcpListener;</span></p><p class="md">fn run<em class="md">server(ip: &str, port: u32) -> std::io::Result<()> {
    let listener = TcpListener::bind(format!("{}:{}", ip, port))?;
    for stream in listener.incoming() {
        match stream {
            Ok(socket) => {
                thread::spawn(move || handle</em>client(socket));<br/>            }<br/>            Err(e) => eprintln!("Error: {e}"),<br/>        }<br/>    }</p><p class="md">    Ok(())<br/>}</p><p class="md"><span class="md line-code"></span><span class="md line-code">
We want a websocket struct. Let's write how we want to use in our handle_client.</span></p><p class="md"><span class="md line-code"></span><span class="md line-code">rust
use std::net::{TcpListener, TcpStream};</span></p><p class="md">fn handle<em class="md">client(socket: TcpStream) {
    let mut websocket = WebSocket::new(socket);
    loop {
        let payload = websocket.try</em>read<em class="md">frame().unwrap(); // Let's keep it simple for now, the unwrap is a good way to focus on the logic first and a reminder of what we need to do.
        websocket.send</em>frame(payload);<br/>        break<br/>    }<br/>}</p><p class="md"><span class="md line-code"></span><span class="md line-code"></span></p><p class="md">We now have a look of what we want. Let's write our websocket module in another file. Don't forget to add the module in the main.</p><p class="md"><span class="md line-code"></span><span class="md line-code">rust
use std::net::TcpStream;</span></p><p class="md">pub struct WebSocket {<br/>    socket: TcpStream,<br/>}</p><p class="md">impl WebSocket {<br/>    pub fn new(socket: TcpStream) -> Self {<br/>        Self { socket }<br/>    }</p><p class="md">    pub fn try<em class="md">to</em>read<em class="md">frame(&mut self) -> Option<String> {
        Some("Hey".to</em>string())<br/>    }</p><p class="md">    pub fn send<em class="md">frame(&mut self, payload: String) {
        println!("Sending: {payload}");
    }
</em></p><p class="md"><span class="md line-code"></span><span class="md line-code">
The </span>try<em class="md">to</em>read<em class="md">frame` and `send</em>frame<span class="md line-code"> functions will be covered in the frame part of this article. Let's focus on the handshake. We will put the logic in our </span>new<span class="md line-code"> function.
We want to read the first http request and print it. Let's add some logic that.</span></p><p class="md">Here is the rewritte of our <span class="md line-code">new</span> function:</p><p class="md"><span class="md line-code"></span><span class="md line-code">rust
    pub fn new(mut socket: TcpStream) -> Self {
        let buffer = read_http_request(&mut socket);
        println!("Request:\n{buffer}");
        Self { socket }
    }</span></p><p class="md"><span class="md line-code"></span><span class="md line-code">
It's pretty self explanotory. Let's write the function </span>read<em class="md">http</em>request<span class="md line-code">. This one won't be in our Struct. It's contain in the new function and is not related to the websocket. It's just a convenience function to read socket. Here is the code:</span></p><p class="md"><span class="md line-code"></span><span class="md line-code">rust
fn read_http_request(socket: &mut TcpStream) -> String {
    let mut retval = String::new();
    let mut buffer = vec![0; 1024];
    loop {
        if let Ok(_) = socket.read(&mut buffer) { // We don't handle the Err case. Our socket is blocking waiting for the whole request to come in.
            let chunk = String::from_utf8_lossy(&buffer);
            if chunk.contains("\r\n\r\n") { // This is where we check if we reached the end of the header.
                let mut splits = chunk.split("\r\n\r\n"); // What ever is after, we drop it. If the client is a websocket client, it won't send anything else.
                let last_chunk = splits.next().unwrap(); // Unwrap will stay, we know for sure that there is at least one \r\n\r\n
                retval.push_str(last_chunk);
                break;
            } else {
                retval.push_str(&chunk);
            }
        }
    }
    retval
}</span></p><p class="md"><span class="md line-code"></span><span class="md line-code">
When we run the program and use postman to send a request. Here is the output:</span></p><p class="md"><span class="md line-code"></span><span class="md line-code">bash
Request:
GET / HTTP/1.1
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: 7hKoimIDBLiE9aYdyn8amA==
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits
Host: 127.0.0.1:8000
thread '<unnamed>' panicked at src/main.rs:29:50:
called </span>Option::unwrap()<span class="md line-code"> on a </span>None<span class="md line-code"> value
note: run with </span>RUST<em class="md">BACKTRACE=1` environment variable to display a backtrac</em></p><p class="md"><span class="md line-code"></span><span class="md line-code">
We can dismiss the error. We can see the basic of a websocket client first request. It has the following lines:</span></p><ul class="md"><li class="md">A legit first line</li><li class="md">header <span class="md line-code">Sec-WebSocket-Version</span> mandatory</li><li class="md">header <span class="md line-code">Sec-WebSocket-Key</span> mandatory</li><li class="md">header <span class="md line-code">Connection</span> mandatory</li><li class="md">header <span class="md line-code">Upgrade</span> mandatory</li><li class="md">header <span class="md line-code">Sec-WebSocket-Extensions</span>, this one is optional. We won't talk about it.</li></ul><h3 class="md">Extract what we need and process the key</h3><p class="md">If we were to make a production grade server, we would have to check headers and return an error in case the client is wrong. We just want to do an echo server. Let's skip that part and go straight to the point. All we want is the client's key. Before going any further, let's write plan a bit aheader. We want to extract the key and then make the header that we will return to the client. Here is our new function:</p><p class="md"><span class="md line-code"></span><span class="md line-code">rust
use std::io::{Read, Write}; // We need to import the Write trait for write_all
impl WebSocket{
    pub fn new(mut socket: TcpStream) -> Self {
        let client_request = read_http_request(&mut socket);
        let key = extract_client_key(client_request);
        let response = build_response(key);
        socket.write_all(response.as_bytes()).unwrap();
        Self { socket }
    }
    //...
}</span></p><p class="md">fn extract<em class="md">client</em>key(client<em class="md">request: String) -> String {
    client</em>request<br/>}</p><p class="md">fn build<em class="md">response(key: String) -> String{
    key
</em></p><p class="md"><span class="md line-code"></span><span class="md line-code"></span></p><p class="md">Let's tackle first the key extraction. If we look at what Postman sent to us, we can determined how we will extract the key. Let's get a look at it.</p><p class="md"><span class="md line-code"></span><span class="md line-code">bash
GET / HTTP/1.1
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: 7hKoimIDBLiE9aYdyn8amA==
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</span></p><p class="md"><span class="md line-code"></span><span class="md line-code">
It's straightforward, we get the lines and then split on </span>:<span class="md line-code">.</span></p><p class="md"><span class="md line-code"></span><span class="md line-code">rust
fn extract_client_key(client_request: String) -> String {
    for line in client_request.lines() {
        if line.contains("Sec-WebSocket-Key") {
            let mut splits = line.split(":");
            splits.next().expect("Error: header wrong format");
            return splits
                .next()
                .expect("Error: no value for websocket key")
                .trim()
                .to_string();
        }
    }
    panic!("Error: not a valid websocket upgrade request")
}</span></p><p class="md"><span class="md line-code"></span><span class="md line-code">
Again, we use a lot of </span>expect<span class="md line-code"> in order to focus on the logic. We iterate thourgh the lines of our request until one of them contains the __Sec-WebSocket-Key__ header.
When we find it, we just splits and return the value. Let's print the key in the next function.</span></p><p class="md"><span class="md line-code"></span><span class="md line-code">rust
fn build_response(key: String) -> String {
    println!("{key}");
    key
}</span></p><p class="md"><span class="md line-code"></span><span class="md line-code"></span></p><p class="md">If we use Postman to check, we print the key.</p><p class="md"><span class="md line-code"></span><span class="md line-code">bash
$ cargo run
rk7yy+5Lp5XJG3Q3zfAdlA==
thread '<unnamed>' panicked at src/main.rs:29:50:
called </span>Option::unwrap()<span class="md line-code"> on a </span>None<span class="md line-code"> value
note: run with </span>RUST<em class="md">BACKTRACE=1` environment variable to display a backtrac</em></p><p class="md"><span class="md line-code"></span><span class="md line-code"></span></p><h3 class="md">How to process the key for the client</h3><p class="md">The only information we need to respond is the <span class="md line-code">Sec-WebSocket-Key</span>. This is a string. We will talk in the client part how to make it. The server just need to process it a certain way. The rfc explain how to do it with an example. Let's quote it:</p><div class="md quote">A |Sec-WebSocket-Accept| header field.  The value of this header field is constructed by concatenating /key/, defined above in step 4 in Section 4.2.2, with the string "258EAFA5- E914-47DA-95CA-C5AB0DC85B11", taking the SHA-1 hash of this concatenated value to obtain a 20-byte value and base64-encoding (see Section 4 of <a href=" this 20-byte hash." class="md">RFC4648</a></div><p class="md">To summary, here are a speudo code:<br/>guid = "258EAFA5- E914-47DA-95CA-C5AB0DC85B11"<br/>concatenated<em class="md">key = concatenate(client</em>key, guid)<br/>digest = sha1(concatenated<em class="md">key)
processed</em>key = bas64.encode(digest)</p><p class="md">The rfc explains why we do that. It is to be sure that a server is able to handle websocket. This is not for security reason. The client will check the key returned by the server and if the expected value is right, it will start sending frame.</p><p class="md">The RFC gives an example. Let's use it as a test case for our code. The client key is dGhlIHNhbXBsZSBub25jZQ==. At the end of the process, it will be: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=.</p><p class="md"><span class="md line-code"></span><span class="md line-code">rust
fn process_key(key: &str) -> String {
    "place holder".to_string()
}</span></p><h1 class="md">[cfg(test)]</h1><p class="md">mod test {<br/>    use super::<em class="md"></em></p><p class="md">    #<a href="    fn it_should_processed_key(" class="md">test</a> {<br/>        let client<em class="md">key = "dGhlIHNhbXBsZSBub25jZQ==";
        let expected = "s3pPLMBiTxaQ9kYGzzhZRbK+xOo="</em></p><p class="md">        let result = process<em class="md">key(client</em>key);<br/>        assert<em class="md">eq!(result, expected);
    }
</em></p><p class="md"><span class="md line-code"></span><span class="md line-code">
Everything does in the </span>websocket.rs<span class="md line-code"> file. We added the function we want with some dummy values. Let's run the test first and you'll see that it fails. Let's write the logic now.
To make it work, we need to use to crates. You can add the following to your **cargo.toml**:</span></p><p class="md"><span class="md line-code"></span><span class="md line-code">yaml
[dependencies]
base64 = "0.22.1"
sha1 = "0.10.6"</span></p><p class="md"><span class="md line-code"></span><span class="md line-code"></span></p><p class="md">We first make the imports we need. <span class="md line-code">Digest</span> is a trait that we need for <span class="md line-code">Sha1::new</span>.</p><p class="md"><span class="md line-code"></span><span class="md line-code">rust
use sha1::{Digest, Sha1};
use std::io::Read;</span></p><p class="md">fn process<em class="md">key(key: &str) -> String {
    let guid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
    let concatenated</em>key = format!("{}{}", key, guid);<br/>    let mut hasher = Sha1::new();<br/>    hasher.update(concatenated<em class="md">key);
    let digest = hasher.finalize();
    BASE64</em>STANDARD.encode(digest)<br/>}</p><p class="md"><span class="md line-code"></span><span class="md line-code"></span></p><p class="md">When we run our test, we can see that it works. The first time I tried to do that, it took me something like 4 or 5 hours. I was making a HashMap of all the headers. For some reason, I decided to lowercase every key/value. That was a very bad idea, eventhough my unit test pass, the program was returning the wrong key because I was making the server key from a lowercased version of the client's key. When someone write something in a RFC, you stick to the spelling and not try to be smarter. I thought that using capital letter was error prone. I've learned my lesson. From now on, I will stick to the standard as much as I can.</p><h3 class="md">Writing our response request.</h3><p class="md">According to the RFC, the server must respond with the following headers and first line:</p><p class="md"><span class="md line-code"></span><span class="md line-code">
HTTP/1.1 101 Switching Protocols\r\n
Upgrade: websocket\r\n
Connection: Upgrade\r\n
Sec-WebSocket-Accept: KEY\r\n
\r\n</span></p><p class="md"><span class="md line-code"></span><span class="md line-code"></span></p><p class="md">The first line is typical from an Http request. We indicate the HTTP version, the status code and the status code description. The KEY is our processed key. Here is our code:</p><p class="md"><span class="md line-code"></span><span class="md line-code">rust
fn build_response(key: String) -> String {
    let server_key = process_key(&key);
    format!(
        "HTTP/1.1 101 Switching Protocols\r\n\
Upgrade: websocket\r\n\
Connection: Upgrade\r\n\
Sec-WebSocket-Accept: {}\r\n\r\n
",
        server_key
    )
}</span></p><p class="md"><span class="md line-code"></span><span class="md line-code"></span></p><p class="md">If we try it with Postman, we see that it managed to connect and was disconnected right away because our handle client thread stops. </p><h2 class="md">The client handshake</h2><p class="md">The code for the client is to written in another project.</p><h3 class="md">Lay down the basic of a TCP connection</h3><p class="md">Let's write how we would like to use the websocket client in our main.</p><p class="md"><span class="md line-code"></span><span class="md line-code">rust
use crate::websocketclient::WebSocketClient;
mod websocketclient;</span></p><p class="md">fn main() {<br/>    let mut websocket = WebSocketClient::new("127.0.0.1", 8000);<br/>    websocket.send<em class="md">frame("Hello, World");
    let response = websocket.read</em>frame();<br/>    println!("Response");<br/>}</p><p class="md"><span class="md line-code"></span><span class="md line-code">
First we want to create a websocket and initialized it in the </span>new<span class="md line-code"> function. Then we would like to send and read something. Let's write our basic WebSocketClient.</span></p><p class="md"><span class="md line-code"></span><span class="md line-code">rust
use std::net::TcpStream;</span></p><p class="md">pub struct WebSocketClient {<br/>    socket: TcpStream,<br/>}</p><p class="md">impl WebSocketClient {<br/>    pub fn new(ip: &str, port: i32) -> Self {<br/>        let socket = TcpStream::connect(format!("{}:{}", ip, port))<br/>            .expect("Error: impossible to connect to remote");<br/>        Self { socket }<br/>    }</p><p class="md">    pub fn send<em class="md">frame(&mut self, payload: &str) {
        println!("Sending: {payload}");
    </em></p><p class="md">    pub fn read<em class="md">frame(&mut self) -> String {
        "Hello World".to</em>string()<br/>    }<br/>}</p><p class="md"><span class="md line-code"></span><span class="md line-code"></span></p><p class="md">The <span class="md line-code">send_frame</span> and <span class="md line-code">read_frame</span> will be covered in the frame section. Let's focus on how make the handshake on the client side.</p><h3 class="md">Writing the flow first</h3><p class="md">We want to send an Http request to the server with the client's key. We can study what postman sent as a working base.</p><p class="md"><span class="md line-code"></span><span class="md line-code">bash
GET / HTTP/1.1
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: 7hKoimIDBLiE9aYdyn8amA==
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits
Host: 127.0.0.1:8000</span></p><p class="md"><span class="md line-code"></span><span class="md line-code"></span></p><p class="md">We want to generate a key, a request and then send it. Let's write the code of our flow with some basic function definitions.</p><p class="md"><span class="md line-code"></span><span class="md line-code">rust
use std::io::Write;</span></p><p class="md">impl WebSocket{<br/>    pub fn new(ip: &str, port: i32) -> Self {<br/>        let socket = TcpStream::connect(format!("{}:{}", ip, port))<br/>            .expect("Error: impossible to connect to remote");<br/>        let key = generate<em class="md">key();
        let request = build</em>request(key);<br/>        socket.write<em class="md">all(request.as</em>bytes()).unwrap();<br/>        check<em class="md">server</em>response(&mut socket);<br/>        Self { socket }<br/>    }<br/>    //...<br/>}</p><p class="md">fn generate<em class="md">key() -> String {
    "dummy</em>key".to<em class="md">string()
</em></p><p class="md">fn build<em class="md">request(key: &str) -> String {
    format!("dummy header {key}")
</em></p><p class="md">fn check<em class="md">server</em>response(socket: &mut TcpStream) {}</p><p class="md"><span class="md line-code"></span><span class="md line-code"></span></p><p class="md">We know what to do next. Let's study the key generation</p><h3 class="md">How to generate the key</h3><p class="md">Let's quote the RFC first:</p><div class="md quote"> The request MUST include a header field with the name |Sec-WebSocket-Key|.  The value of this header field MUST be a nonce consisting of a randomly selected 16-byte value that has been base64-encoded (see Section 4 of <a href=". The nonce MUST be selected randomly for each connection." class="md">RFC4648</a></div><p class="md">In pseudo code, the generation looks like.</p><p class="md"><span class="md line-code"></span><span class="md line-code">rust
let nonce = generate_16_byte_long_string();
base64.encode(nonce)</span></p><p class="md"><span class="md line-code"></span><span class="md line-code"></span></p><p class="md">First we will need the base64 library we use for the server and the rand library. Let's add that in our <span class="md line-code">cargo.toml</span></p><p class="md"><span class="md line-code"></span><span class="md line-code">toml
rand = "0.9.0"
base64 = "0.22.1"</span></p><p class="md"><span class="md line-code"></span><span class="md line-code"></span></p><p class="md">Then here is the code to generate the key:</p><p class="md"><span class="md line-code"></span><span class="md line-code">rust
fn generate_key() -> String {
    let mut rng = rand::rng();
    let mut key = String::new();</span></p><p class="md">    for <em class="md"> in 0..16 {
        key.push(rng.random::<char>());
    }
    BASE64</em>STANDARD.encode(key)<br/>}</p><p class="md"><span class="md line-code"></span><span class="md line-code"></span></p><p class="md"> ### Sending the handshake init request<br/>We just need to take the Http header we see earlier, remove the optional header and put our fresly generated key. It looks like this:</p><p class="md"><span class="md line-code"></span><span class="md line-code">rust
fn build_request(key: &str) -> String {
    let request = format!(
        "GET / HTTP/1.1\r\n\
Sec-WebSocket-Version: 13\r\n\
Sec-WebSocket-Key: {key}\r\n\
Connection: Upgrade\r\n\
Upgrade: websocket\r\n\
Host: 127.0.0.1:8000\r\n\r\n"
    )
}</span></p><p class="md"><span class="md line-code"></span><span class="md line-code"></span></p><p class="md">We will use our own server to interact. Because we don't really check the header, we know it will work. Let's display the server response.</p><p class="md"><span class="md line-code"></span><span class="md line-code">rust
fn check_server_response(socket: &mut TcpStream) {
    let response = read_server_http_response(socket).unwrap();
    println!("{response}")
}</span></p><p class="md">fn read<em class="md">server</em>http<em class="md">response(socket: &mut TcpStream) -> Option<String> {
    let mut buffer = vec![0; 1024];
    let mut response = String::new();
    loop {
        if let Ok(</em>) = socket.read(&mut buffer) {<br/>            let chunk = String::from<em class="md">utf8</em>lossy(&buffer);<br/>            if chunk.contains("\r\n\r\n") {<br/>                let chunk = chunk.split("\r\n\r\n").next().unwrap();<br/>                response.push<em class="md">str(&chunk);
                return Some(response);
            }
            response.push</em>str(&chunk);<br/>        } else {<br/>            break;<br/>        }<br/>    }<br/>    None<br/>}</p><p class="md"><span class="md line-code"></span><span class="md line-code"></span></p><p class="md">The logic is from the server. We read the stream until we find \r\n\r\n and we return the response.</p><p class="md"><span class="md line-code"></span><span class="md line-code">bash
$ cargo run
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: LfBTW9X7bjL2jHlPdymxQ8kJ7tk=</span></p><p class="md"><span class="md line-code"></span><span class="md line-code"></span></p><p class="md">We recognize the header we wrote earlier. We're right on track. Let's now check if the server returns a valid key.<br/>Let's first write how we want the logic to work according to what we know. We want first to extract the key. We want to use the key we send to compare with what the server return. Thus we need to transform the key we sent the same way and compare with the server result. Let's replace the println with this code:</p><p class="md"><span class="md line-code"></span><span class="md line-code">rust
fn check_server_response(socket: &mut TcpStream, key: String) {
    let response = read_server_http_response(socket).unwrap();
    let client_key = extract_server_key(&response);
    let control_key = get_control_key(&key);
    if client_key != control_key {
        panic!("Error: wrong Sec-WebSocket-Accept key");
    }
}</span></p><p class="md">fn extract<em class="md">server</em>key(response: &str) -> String {<br/>    response.to<em class="md">string()
</em></p><p class="md">fn get<em class="md">control</em>key(key: &str) -> String {<br/>    key.to<em class="md">string()
</em></p><p class="md"><span class="md line-code"></span><span class="md line-code"></span></p><p class="md">First we want to extract the server key. We already know how to do that.</p><p class="md"><span class="md line-code"></span><span class="md line-code">rust
fn extract_server_key(response: &str) -> String {
    for line in response.lines() {
        if line.contains("Sec-WebSocket-Accept") {
            let mut splits = line.split(":");
            splits.next().expect("Error: header wrong format");
            return splits
                .next()
                .expect("Error: no value for websocket key")
                .trim()
                .to_string();
        }
    }
    panic!("Error: not a valid websocket upgrade response")
}</span></p><p class="md"><span class="md line-code"></span><span class="md line-code"></span></p><p class="md">Be carefull, we are looking for <span class="md line-code">Sec-WebSocket-Accept</span>.<br/>The control key follows the same logic as the server. We need to add the <span class="md line-code">sha</span> library in our cargo.toml.</p><p class="md"><span class="md line-code"></span><span class="md line-code">toml
[dependencies]
rand = "0.9.0"
base64 = "0.22.1"
sha1 = "0.10.6"</span></p><p class="md"><span class="md line-code"></span><span class="md line-code"></span></p><p class="md">Here is the code.</p><p class="md"><span class="md line-code"></span><span class="md line-code">rust
use sha1::{Digest, Sha1};</span></p><p class="md">fn get<em class="md">control</em>key(key: &str) -> String {<br/>    let guid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";<br/>    let concatenated<em class="md">key = format!("{}{}", key, guid);
    let mut hasher = Sha1::new();
    hasher.update(concatenated</em>key);<br/>    let digest = hasher.finalize();<br/>    BASE64<em class="md">STANDARD.encode(digest)
</em></p><p class="md"><span class="md line-code"></span><span class="md line-code"></span></p><p class="md">Let's add a print in our main to see if it works. If it doesn't, the program will crash because the control key is not like the server key.</p><p class="md"><span class="md line-code"></span><span class="md line-code">rust
fn main() {
    let mut websocket = WebSocketClient::new("127.0.0.1", 8000);
    println!("Handshake done");
    ...
}</span></p><p class="md"><span class="md line-code"></span><span class="md line-code"></span></p><p class="md">let's try it.</p><p class="md"><span class="md line-code"></span><span class="md line-code">bash
$ cargo run
Handshake done</span></p><p class="md"><span class="md line-code"></span><span class="md line-code"></span></p><p class="md">It worked. Nice job. We just made a working websocket handshake. From now on, our server and client will only communicate using frame. We'll see how it looks like in another article.</p><p class="md">The huge benefit with websocket is that, once the handshake is done, the TCP/TLS connection stay opened. This two protocols carry some overhead. They have handshake on their own and the TLS add some encryption. When we use Websocket, we dont' have to remake the TCP and TLS handshake which saves some time. It's faster.</p>
    </div>
</div>
            </div>
        </body>
    </html>
    